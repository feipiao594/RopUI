# 跨平台调度器开发

这个阶段的任务主要是实现各个平台的 eventloop_core 用来提供不同平台的监听事件

目前 Linux 平台已经完整支持

Windows/MacOS 平台需要测试

严重警告：windows 平台的 api 依赖一个不可以重复的 key 值，需要在后期加入一个全局 key 池来避免 key 碰撞，非常注意，wakeup 目前硬编码了这个 key 值，后期一定一定要改

注意 watcher 的设计，就是被回掉捕获的 watcher 持有的资源需要 shared_ptr 包一层，因为能不捕获 this 就不捕获（优先 State 或把资源/逻辑放进 source）。例子如 wakeupWatcher 系列
只有当确实没办法要捕获 this 时，才用 weak_ptr 兜底（并把 watcher 做成 shared_ptr 生命周期）。例子如 example/tcp_client_example


macos:
```objectivec
NSEvent* ev = [NSEvent otherEventWithType:NSEventTypeApplicationDefined
                                 location:NSZeroPoint
                            modifierFlags:0
                                timestamp:0
                             windowNumber:0
                                  context:nil
                                  subtype:0
                                    data1:0
                                    data2:0];
```

这边我们规定了 wakeup 自定义事件的 subtype 是 0

## Work-Stealing 可视化（自写解析器版本）

目标：把调度器关键事件以“可解析的一行日志”输出到文本文件，再用 Python 离线解析/生成图表。

### 1) Trace 日志格式
调度器会在 `ROP_SCHED_TRACE=1` 时输出形如：

`SCHED|<ts_ns>|<worker_id>|<event>|k=v k=v ...`

目前的关键事件：
- `local_push`：向本 worker 的 local deque 投递（做了采样输出）。
- `local_degrade_global`：local 满或非 owner 线程调用，退化到 global。
- `steal_success`：窃取成功（含 victim/stolen/local/victim_local）。

### 2) 触发 stealing 的可重复场景
仓库内置了一个 demo：`example/work_steal_trace_demo`。
- 用 `Hive::postToWorker(0, ...)` 保证“生产任务”的种子在 worker0 上跑。
- 种子任务在 worker0 上通过 `IOWorker::postToLocal(...)` 生成大量本地 backlog。
- 其他 worker 通过短周期 timer 保持唤醒，从而在 global 空时会进入 Step-6 去 steal。

### 3) 解析与可视化
解析脚本：`tools/sched_trace/parse_sched_trace.py`
- 输入：日志文件（或 stdin）
- 输出：按 worker 汇总 stealing 数据；可选生成一个只画 `steal_success` 的简易 SVG 时间线。

动画回放（离线 HTML）：`tools/sched_trace/gen_sched_trace_anim.py`
- 输出：一个本地 `html` 文件，用浏览器打开即可播放（不需要跑 webconsole，更不会被调度器影响）。

示例流程：
- 构建：`cmake -S . -B build -DROPUI_BUILD_EXAMPLES=ON && cmake --build build -j`
- 运行并输出日志（二选一）：
  - 环境变量：`ROP_SCHED_TRACE=1 ./build/example/work_steal_trace_demo/work_steal_trace_demo --log trace.log`
  - 启动参数：`./build/example/work_steal_trace_demo/work_steal_trace_demo --sched-trace --log trace.log`
- 解析并生成 SVG：`python3 tools/sched_trace/parse_sched_trace.py trace.log --svg trace.svg`
- 生成动画 HTML：`python3 tools/sched_trace/gen_sched_trace_anim.py trace.log -o trace_anim.html`



在 64 位操作系统上，现有的双向队列自程序启动到正常使用最大上限的偷取次数是 size_t 的最大值，在某些 32 位操作系统上由于该特性进程可能在不到一年内因达到该上限溢出而导致偷取任务这个行为完全失败，但程序应该会降级成普通 eventloop，64 位操作系统的话足够该进程用到天荒地老了
后续可能需要修复这个问题，直接改 uint64_t 就好了